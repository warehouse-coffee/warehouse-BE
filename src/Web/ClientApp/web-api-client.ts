//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import followIfLoginRedirect from './api-authorization/followIfLoginRedirect';

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    getAntiforgeryToken(): Promise<string> {
        let url_ = this.baseUrl + "/antiforgery/token";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAntiforgeryToken(_response);
        });
    }

    protected processGetAntiforgeryToken(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class AreasClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    createArea(command: CreateAreaCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Areas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateArea(_response);
        });
    }

    protected processCreateArea(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }
}

export class CategoriesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    createCategory(command: CreateCategoryCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCategory(_response);
        });
    }

    protected processCreateCategory(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    getCategoryList(): Promise<CategoryListVM> {
        let url_ = this.baseUrl + "/api/Categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategoryList(_response);
        });
    }

    protected processGetCategoryList(response: Response): Promise<CategoryListVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryListVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryListVM>(null as any);
    }
}

export class CoffeePriceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    getCoffeePricePredictGraph(): Promise<GraphVM> {
        let url_ = this.baseUrl + "/api/CoffeePrice/predict-graph";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCoffeePricePredictGraph(_response);
        });
    }

    protected processGetCoffeePricePredictGraph(response: Response): Promise<GraphVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GraphVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GraphVM>(null as any);
    }
}

export class CompaniesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    createCompany(command: CreateCompanyCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Companies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCompany(_response);
        });
    }

    protected processCreateCompany(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    getCompanyList(): Promise<CompanyListVM> {
        let url_ = this.baseUrl + "/api/Companies";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompanyList(_response);
        });
    }

    protected processGetCompanyList(response: Response): Promise<CompanyListVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyListVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyListVM>(null as any);
    }

    getCompanyDetail(companyId: string): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Companies/{companyId}";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompanyDetail(_response);
        });
    }

    protected processGetCompanyDetail(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    updateCompany(companyId: string, command: UpdateCompanyCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Companies/{companyId}";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCompany(_response);
        });
    }

    protected processUpdateCompany(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    deleteCompany(companyId: string): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Companies/{companyId}";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCompany(_response);
        });
    }

    protected processDeleteCompany(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }
}

export class CompanyOwnerClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    create(command: CreateCompanyOwnerCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/CompanyOwner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    getAll(query: GetCompanyOwnerListQuery): Promise<CompanyOwnerListVM> {
        let url_ = this.baseUrl + "/api/CompanyOwner/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<CompanyOwnerListVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyOwnerListVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyOwnerListVM>(null as any);
    }

    getDetail(id: string): Promise<CompanyOwnerDetailDto> {
        let url_ = this.baseUrl + "/api/CompanyOwner/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDetail(_response);
        });
    }

    protected processGetDetail(response: Response): Promise<CompanyOwnerDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyOwnerDetailDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyOwnerDetailDto>(null as any);
    }

    update(command: UpdateCompanyOwnerCommand, id: string): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/CompanyOwner/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (command === undefined || command === null)
            throw new Error("The parameter 'command' must be defined and cannot be null.");
        else
            url_ += "command=" + encodeURIComponent("" + command) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    delete(id: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/CompanyOwner/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class ConfigurationsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    createConfig(command: CreateConfigCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Configurations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateConfig(_response);
        });
    }

    protected processCreateConfig(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    getAllConfig(): Promise<ConfigVm> {
        let url_ = this.baseUrl + "/api/Configurations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllConfig(_response);
        });
    }

    protected processGetAllConfig(response: Response): Promise<ConfigVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConfigVm>(null as any);
    }
}

export class CrawClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    getLinks(): Promise<CommodityLinks> {
        let url_ = this.baseUrl + "/api/Craw/links";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLinks(_response);
        });
    }

    protected processGetLinks(response: Response): Promise<CommodityLinks> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommodityLinks.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommodityLinks>(null as any);
    }

    getCraws(): Promise<CrawlResponse> {
        let url_ = this.baseUrl + "/api/Craw/craws";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCraws(_response);
        });
    }

    protected processGetCraws(response: Response): Promise<CrawlResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CrawlResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CrawlResponse>(null as any);
    }

    getCrawsAll(): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Craw/crawsAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCrawsAll(_response);
        });
    }

    protected processGetCrawsAll(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }
}

export class CustomersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    createCustomer(command: CreateCustomerCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Customers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCustomer(_response);
        });
    }

    protected processCreateCustomer(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    getCustomerDetail(id: number): Promise<CustomerDetailDto> {
        let url_ = this.baseUrl + "/api/Customers?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCustomerDetail(_response);
        });
    }

    protected processGetCustomerDetail(response: Response): Promise<CustomerDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDetailDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerDetailDto>(null as any);
    }

    getCustomerOfCompany(): Promise<CustomersVM> {
        let url_ = this.baseUrl + "/api/Customers/company";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCustomerOfCompany(_response);
        });
    }

    protected processGetCustomerOfCompany(response: Response): Promise<CustomersVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomersVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomersVM>(null as any);
    }

    deleteCustomer(id: number): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCustomer(_response);
        });
    }

    protected processDeleteCustomer(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    updateCustomer(id: number, command: UpdateCustomerCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCustomer(_response);
        });
    }

    protected processUpdateCustomer(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }
}

export class EmployeesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    createEmployee(command: CreateEmployeeCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Employees";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEmployee(_response);
        });
    }

    protected processCreateEmployee(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    updateEmployee(command: UpdateEmployeeCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Employees";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEmployee(_response);
        });
    }

    protected processUpdateEmployee(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    getListEmployee(query: GetListEmployeeQuery): Promise<EmployeeListVM> {
        let url_ = this.baseUrl + "/api/Employees/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetListEmployee(_response);
        });
    }

    protected processGetListEmployee(response: Response): Promise<EmployeeListVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeListVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmployeeListVM>(null as any);
    }

    getEmployeeDetail(id: string): Promise<EmployeeDetailVM> {
        let url_ = this.baseUrl + "/api/Employees/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEmployeeDetail(_response);
        });
    }

    protected processGetEmployeeDetail(response: Response): Promise<EmployeeDetailVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDetailVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmployeeDetailVM>(null as any);
    }

    deleteEmployee(id: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Employees/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEmployee(_response);
        });
    }

    protected processDeleteEmployee(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class IdentityUserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    signIn(query: SignInCommand): Promise<SignInVm> {
        let url_ = this.baseUrl + "/api/IdentityUser/signin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignIn(_response);
        });
    }

    protected processSignIn(response: Response): Promise<SignInVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SignInVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SignInVm>(null as any);
    }

    resetPassword(command: ResetPasswordCommand): Promise<ResetPasswordVm> {
        let url_ = this.baseUrl + "/api/IdentityUser/resetpassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<ResetPasswordVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResetPasswordVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResetPasswordVm>(null as any);
    }

    logout(id: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/IdentityUser/logout?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class InventoriesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    getInventoryProductList(query: GetListProductOfInventory): Promise<InventoryProductsListVM> {
        let url_ = this.baseUrl + "/api/Inventories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInventoryProductList(_response);
        });
    }

    protected processGetInventoryProductList(response: Response): Promise<InventoryProductsListVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryProductsListVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryProductsListVM>(null as any);
    }

    deleteInventoryProduct(id: number): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Inventories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteInventoryProduct(_response);
        });
    }

    protected processDeleteInventoryProduct(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    getInventoriesByStorage(query: GetInventoriesByStorageQuery): Promise<InventoryListVM> {
        let url_ = this.baseUrl + "/api/Inventories/storageId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInventoriesByStorage(_response);
        });
    }

    protected processGetInventoriesByStorage(response: Response): Promise<InventoryListVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryListVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryListVM>(null as any);
    }
}

export class InventoriesOutboundClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    createInventoryOutbound(command: CreateInventoryOutboundCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/InventoriesOutbound";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateInventoryOutbound(_response);
        });
    }

    protected processCreateInventoryOutbound(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }
}

export class LLMClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    getResponseIntent(intent: string | undefined): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/LLM/intent?";
        if (intent === null)
            throw new Error("The parameter 'intent' cannot be null.");
        else if (intent !== undefined)
            url_ += "intent=" + encodeURIComponent("" + intent) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetResponseIntent(_response);
        });
    }

    protected processGetResponseIntent(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }
}

export class LogsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    getLogs(query: GetLogListQuery): Promise<LogList> {
        let url_ = this.baseUrl + "/api/Logs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLogs(_response);
        });
    }

    protected processGetLogs(response: Response): Promise<LogList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogList.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LogList>(null as any);
    }
}

export class OrdersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    importProduct(command: ImportStogareCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Orders/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImportProduct(_response);
        });
    }

    protected processImportProduct(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    getList(query: GetOrderListQuery): Promise<OrderListVM> {
        let url_ = this.baseUrl + "/api/Orders/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: Response): Promise<OrderListVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderListVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderListVM>(null as any);
    }

    deleteOrder(id: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteOrder(_response);
        });
    }

    protected processDeleteOrder(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    getOrderDetail(id: string): Promise<OrderDetailVM> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrderDetail(_response);
        });
    }

    protected processGetOrderDetail(response: Response): Promise<OrderDetailVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDetailVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderDetailVM>(null as any);
    }

    saleOrder(command: SaleOrderCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Orders/sale";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaleOrder(_response);
        });
    }

    protected processSaleOrder(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    getTopOrder(): Promise<SaleAndImportOrderVM> {
        let url_ = this.baseUrl + "/api/Orders/top5";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTopOrder(_response);
        });
    }

    protected processGetTopOrder(response: Response): Promise<SaleAndImportOrderVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaleAndImportOrderVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SaleAndImportOrderVM>(null as any);
    }

    getImportOrderList(query: GetImportOrderListQuery): Promise<OrderListVM> {
        let url_ = this.baseUrl + "/api/Orders/getimport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetImportOrderList(_response);
        });
    }

    protected processGetImportOrderList(response: Response): Promise<OrderListVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderListVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderListVM>(null as any);
    }

    getSaleOrderList(query: GetSaleOrderListQuery): Promise<OrderListVM> {
        let url_ = this.baseUrl + "/api/Orders/getsale";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSaleOrderList(_response);
        });
    }

    protected processGetSaleOrderList(response: Response): Promise<OrderListVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderListVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderListVM>(null as any);
    }
}

export class ProductsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    getProductList(query: GetProductListQuery): Promise<ProductListVM> {
        let url_ = this.baseUrl + "/api/Products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductList(_response);
        });
    }

    protected processGetProductList(response: Response): Promise<ProductListVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductListVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductListVM>(null as any);
    }

    getProductsOrder(): Promise<ProductsOrderVM> {
        let url_ = this.baseUrl + "/api/Products/product-order";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductsOrder(_response);
        });
    }

    protected processGetProductsOrder(response: Response): Promise<ProductsOrderVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductsOrderVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductsOrderVM>(null as any);
    }
}

export class ReportStorageClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    getReportStorage(dateStart: Date, dateEnd: Date): Promise<ReportVM> {
        let url_ = this.baseUrl + "/api/ReportStorage?";
        if (dateStart === undefined || dateStart === null)
            throw new Error("The parameter 'dateStart' must be defined and cannot be null.");
        else
            url_ += "dateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toISOString() : "") + "&";
        if (dateEnd === undefined || dateEnd === null)
            throw new Error("The parameter 'dateEnd' must be defined and cannot be null.");
        else
            url_ += "dateEnd=" + encodeURIComponent(dateEnd ? "" + dateEnd.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReportStorage(_response);
        });
    }

    protected processGetReportStorage(response: Response): Promise<ReportVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReportVM>(null as any);
    }
}

export class StatsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    getAdminStats(): Promise<AdminStatsVM> {
        let url_ = this.baseUrl + "/api/Stats/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAdminStats(_response);
        });
    }

    protected processGetAdminStats(response: Response): Promise<AdminStatsVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminStatsVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AdminStatsVM>(null as any);
    }

    getEmployeeStats(): Promise<EmployeeStatsVM> {
        let url_ = this.baseUrl + "/api/Stats/employee";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEmployeeStats(_response);
        });
    }

    protected processGetEmployeeStats(response: Response): Promise<EmployeeStatsVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeStatsVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmployeeStatsVM>(null as any);
    }
}

export class StorageClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    createStorage(command: CreateStorageCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Storage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateStorage(_response);
        });
    }

    protected processCreateStorage(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    getStorageList(): Promise<StorageListVM> {
        let url_ = this.baseUrl + "/api/Storage";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStorageList(_response);
        });
    }

    protected processGetStorageList(response: Response): Promise<StorageListVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StorageListVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StorageListVM>(null as any);
    }

    updateStorage(command: UpdateStorageCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Storage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateStorage(_response);
        });
    }

    protected processUpdateStorage(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    getStorageOfUser(query: GetStorageOfUserQuery): Promise<UserStorageList> {
        let url_ = this.baseUrl + "/api/Storage/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStorageOfUser(_response);
        });
    }

    protected processGetStorageOfUser(response: Response): Promise<UserStorageList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserStorageList.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserStorageList>(null as any);
    }

    getListStorageInfoOfUser(): Promise<ListISorageInfoOfUserVM> {
        let url_ = this.baseUrl + "/api/Storage/user-list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetListStorageInfoOfUser(_response);
        });
    }

    protected processGetListStorageInfoOfUser(response: Response): Promise<ListISorageInfoOfUserVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListISorageInfoOfUserVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListISorageInfoOfUserVM>(null as any);
    }

    getStorageProducts(query: GetStorageProductsQuery): Promise<StorageProductListVM> {
        let url_ = this.baseUrl + "/api/Storage/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStorageProducts(_response);
        });
    }

    protected processGetStorageProducts(response: Response): Promise<StorageProductListVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StorageProductListVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StorageProductListVM>(null as any);
    }

    getStorageDetailUpdate(id: number): Promise<StorageDto3> {
        let url_ = this.baseUrl + "/api/Storage/detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStorageDetailUpdate(_response);
        });
    }

    protected processGetStorageDetailUpdate(response: Response): Promise<StorageDto3> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StorageDto3.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StorageDto3>(null as any);
    }

    deleteStorage(id: number): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/Storage/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteStorage(_response);
        });
    }

    protected processDeleteStorage(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }
}

export class SuperAdminClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    private token: string;
    private XSRF: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, token?: string, XSRF?: string) {
         this.http = http || { fetch: fetch as any };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        this.token = token || "";
        this.XSRF = XSRF || "";
    }

    userRegister(command: CreateUserCommand): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/SuperAdmin/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserRegister(_response);
        });
    }

    protected processUserRegister(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    getAllUsers(query: GetUserListQuery): Promise<UserListVm> {
        let url_ = this.baseUrl + "/api/SuperAdmin/user/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllUsers(_response);
        });
    }

    protected processGetAllUsers(response: Response): Promise<UserListVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserListVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserListVm>(null as any);
    }

    getUserDetail(id: string): Promise<UserVM> {
        let url_ = this.baseUrl + "/api/SuperAdmin/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserDetail(_response);
        });
    }

    protected processGetUserDetail(response: Response): Promise<UserVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserVM>(null as any);
    }

    deleteUser(id: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/SuperAdmin/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    updateUser(command: UpdateUserCommand, id: string): Promise<ResponseDto> {
        let url_ = this.baseUrl + "/api/SuperAdmin/user/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (command === undefined || command === null)
            throw new Error("The parameter 'command' must be defined and cannot be null.");
        else
            url_ += "command=" + encodeURIComponent("" + command) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<ResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseDto>(null as any);
    }

    getSuperAdminStats(): Promise<SuperAdminStatsVM> {
        let url_ = this.baseUrl + "/api/SuperAdmin/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json",
                "Authorization": `Bearer ${this.token}`,
                "X-XSRF-TOKEN": `${this.XSRF}`,
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSuperAdminStats(_response);
        });
    }

    protected processGetSuperAdminStats(response: Response): Promise<SuperAdminStatsVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SuperAdminStatsVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SuperAdminStatsVM>(null as any);
    }
}

export class ResponseDto implements IResponseDto {
    statusCode?: number;
    message?: string;
    data?: any | undefined;

    constructor(data?: IResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): ResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data;
        return data;
    }
}

export interface IResponseDto {
    statusCode?: number;
    message?: string;
    data?: any | undefined;
}

export class CreateAreaCommand implements ICreateAreaCommand {
    areaName?: string;

    constructor(data?: ICreateAreaCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.areaName = _data["areaName"];
        }
    }

    static fromJS(data: any): CreateAreaCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAreaCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areaName"] = this.areaName;
        return data;
    }
}

export interface ICreateAreaCommand {
    areaName?: string;
}

export class CreateCategoryCommand implements ICreateCategoryCommand {
    category?: CategoryDto;

    constructor(data?: ICreateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"] ? CategoryDto.fromJS(_data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateCategoryCommand {
    category?: CategoryDto;
}

export class CategoryDto implements ICategoryDto {
    name?: string | undefined;
    products?: ProductDto[] | undefined;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategoryDto {
    name?: string | undefined;
    products?: ProductDto[] | undefined;
}

export class ProductDto implements IProductDto {
    name?: string | undefined;
    units?: string | undefined;
    quantity?: number;
    image?: string | undefined;
    status?: string | undefined;
    expiration?: Date | undefined;
    importDate?: Date | undefined;
    exportDate?: Date | undefined;
    categoryId?: number | undefined;
    areaId?: number | undefined;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.units = _data["units"];
            this.quantity = _data["quantity"];
            this.image = _data["image"];
            this.status = _data["status"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.importDate = _data["importDate"] ? new Date(_data["importDate"].toString()) : <any>undefined;
            this.exportDate = _data["exportDate"] ? new Date(_data["exportDate"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.areaId = _data["areaId"];
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["units"] = this.units;
        data["quantity"] = this.quantity;
        data["image"] = this.image;
        data["status"] = this.status;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["importDate"] = this.importDate ? this.importDate.toISOString() : <any>undefined;
        data["exportDate"] = this.exportDate ? this.exportDate.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["areaId"] = this.areaId;
        return data;
    }
}

export interface IProductDto {
    name?: string | undefined;
    units?: string | undefined;
    quantity?: number;
    image?: string | undefined;
    status?: string | undefined;
    expiration?: Date | undefined;
    importDate?: Date | undefined;
    exportDate?: Date | undefined;
    categoryId?: number | undefined;
    areaId?: number | undefined;
}

export class CategoryListVM implements ICategoryListVM {
    categories?: CategoryDto2[];

    constructor(data?: ICategoryListVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(CategoryDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryListVM {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryListVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategoryListVM {
    categories?: CategoryDto2[];
}

export class CategoryDto2 implements ICategoryDto2 {
    id?: number;
    name?: string | undefined;
    companyId?: string | undefined;

    constructor(data?: ICategoryDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): CategoryDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        return data;
    }
}

export interface ICategoryDto2 {
    id?: number;
    name?: string | undefined;
    companyId?: string | undefined;
}

export class GraphVM implements IGraphVM {
    pointInfos?: PointInfo[];

    constructor(data?: IGraphVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["pointInfos"])) {
                this.pointInfos = [] as any;
                for (let item of _data["pointInfos"])
                    this.pointInfos!.push(PointInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GraphVM {
        data = typeof data === 'object' ? data : {};
        let result = new GraphVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pointInfos)) {
            data["pointInfos"] = [];
            for (let item of this.pointInfos)
                data["pointInfos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGraphVM {
    pointInfos?: PointInfo[];
}

export class PointInfo implements IPointInfo {
    date?: string | undefined;
    ai_predict?: number;
    real_price_difference_rate?: number;
    aI_predict_money?: number;
    real_price_money?: number;

    constructor(data?: IPointInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.ai_predict = _data["ai_predict"];
            this.real_price_difference_rate = _data["real_price_difference_rate"];
            this.aI_predict_money = _data["aI_predict_money"];
            this.real_price_money = _data["real_price_money"];
        }
    }

    static fromJS(data: any): PointInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PointInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["ai_predict"] = this.ai_predict;
        data["real_price_difference_rate"] = this.real_price_difference_rate;
        data["aI_predict_money"] = this.aI_predict_money;
        data["real_price_money"] = this.real_price_money;
        return data;
    }
}

export interface IPointInfo {
    date?: string | undefined;
    ai_predict?: number;
    real_price_difference_rate?: number;
    aI_predict_money?: number;
    real_price_money?: number;
}

export class CreateCompanyCommand implements ICreateCompanyCommand {
    companyId?: string;
    companyName?: string;
    phone?: string;
    email?: string;

    constructor(data?: ICreateCompanyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): CreateCompanyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompanyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        return data;
    }
}

export interface ICreateCompanyCommand {
    companyId?: string;
    companyName?: string;
    phone?: string;
    email?: string;
}

export class CompanyListVM implements ICompanyListVM {
    companyList?: CompanyDto[];

    constructor(data?: ICompanyListVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["companyList"])) {
                this.companyList = [] as any;
                for (let item of _data["companyList"])
                    this.companyList!.push(CompanyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompanyListVM {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyListVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.companyList)) {
            data["companyList"] = [];
            for (let item of this.companyList)
                data["companyList"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICompanyListVM {
    companyList?: CompanyDto[];
}

export class CompanyDto implements ICompanyDto {
    companyId?: string | undefined;
    companyName?: string | undefined;
    phoneContact?: string | undefined;

    constructor(data?: ICompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.phoneContact = _data["phoneContact"];
        }
    }

    static fromJS(data: any): CompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["phoneContact"] = this.phoneContact;
        return data;
    }
}

export interface ICompanyDto {
    companyId?: string | undefined;
    companyName?: string | undefined;
    phoneContact?: string | undefined;
}

export class UpdateCompanyCommand implements IUpdateCompanyCommand {
    companyId?: string;
    companyName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;

    constructor(data?: IUpdateCompanyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UpdateCompanyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        return data;
    }
}

export interface IUpdateCompanyCommand {
    companyId?: string;
    companyName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
}

export class CreateCompanyOwnerCommand implements ICreateCompanyOwnerCommand {
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;

    constructor(data?: ICreateCompanyOwnerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): CreateCompanyOwnerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompanyOwnerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface ICreateCompanyOwnerCommand {
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
}

export class CompanyOwnerListVM implements ICompanyOwnerListVM {
    companyOwners?: UserDto[];
    page?: Page | undefined;

    constructor(data?: ICompanyOwnerListVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["companyOwners"])) {
                this.companyOwners = [] as any;
                for (let item of _data["companyOwners"])
                    this.companyOwners!.push(UserDto.fromJS(item));
            }
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CompanyOwnerListVM {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyOwnerListVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.companyOwners)) {
            data["companyOwners"] = [];
            for (let item of this.companyOwners)
                data["companyOwners"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICompanyOwnerListVM {
    companyOwners?: UserDto[];
    page?: Page | undefined;
}

export class UserDto implements IUserDto {
    id?: string | undefined;
    companyId?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    roleName?: string | undefined;
    isActived?: boolean;
    avatarImage?: string | undefined;
    storages?: Storage[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.roleName = _data["roleName"];
            this.isActived = _data["isActived"];
            this.avatarImage = _data["avatarImage"];
            if (Array.isArray(_data["storages"])) {
                this.storages = [] as any;
                for (let item of _data["storages"])
                    this.storages!.push(Storage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["roleName"] = this.roleName;
        data["isActived"] = this.isActived;
        data["avatarImage"] = this.avatarImage;
        if (Array.isArray(this.storages)) {
            data["storages"] = [];
            for (let item of this.storages)
                data["storages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserDto {
    id?: string | undefined;
    companyId?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    roleName?: string | undefined;
    isActived?: boolean;
    avatarImage?: string | undefined;
    storages?: Storage[] | undefined;
}

export abstract class BaseEntity implements IBaseEntity {
    id?: number;
    domainEvents?: BaseEvent[];

    constructor(data?: IBaseEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                this.domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    this.domainEvents!.push(BaseEvent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaseEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBaseEntity {
    id?: number;
    domainEvents?: BaseEvent[];
}

export abstract class BaseAuditableEntity extends BaseEntity implements IBaseAuditableEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date;
    lastModifiedBy?: string | undefined;
    isDeleted?: boolean;

    constructor(data?: IBaseAuditableEntity) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static override fromJS(data: any): BaseAuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseAuditableEntity' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["isDeleted"] = this.isDeleted;
        super.toJSON(data);
        return data;
    }
}

export interface IBaseAuditableEntity extends IBaseEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date;
    lastModifiedBy?: string | undefined;
    isDeleted?: boolean;
}

export class Storage extends BaseAuditableEntity implements IStorage {
    name?: string;
    location?: string;
    status?: StorageStatus;
    companyId?: string | undefined;
    areas?: Area[] | undefined;
    inventories?: Inventory[];
    userStorages?: UserStorage[];

    constructor(data?: IStorage) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.location = _data["location"];
            this.status = _data["status"];
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(Area.fromJS(item));
            }
            if (Array.isArray(_data["inventories"])) {
                this.inventories = [] as any;
                for (let item of _data["inventories"])
                    this.inventories!.push(Inventory.fromJS(item));
            }
            if (Array.isArray(_data["userStorages"])) {
                this.userStorages = [] as any;
                for (let item of _data["userStorages"])
                    this.userStorages!.push(UserStorage.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Storage {
        data = typeof data === 'object' ? data : {};
        let result = new Storage();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["location"] = this.location;
        data["status"] = this.status;
        data["companyId"] = this.companyId;
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        if (Array.isArray(this.inventories)) {
            data["inventories"] = [];
            for (let item of this.inventories)
                data["inventories"].push(item.toJSON());
        }
        if (Array.isArray(this.userStorages)) {
            data["userStorages"] = [];
            for (let item of this.userStorages)
                data["userStorages"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IStorage extends IBaseAuditableEntity {
    name?: string;
    location?: string;
    status?: StorageStatus;
    companyId?: string | undefined;
    areas?: Area[] | undefined;
    inventories?: Inventory[];
    userStorages?: UserStorage[];
}

export enum StorageStatus {
    Active = 0,
    UnderMaintenance = 1,
    Inactive = 2,
    Closed = 3,
}

export class Area extends BaseAuditableEntity implements IArea {
    name?: string;
    storageId?: number;
    products?: Product[];

    constructor(data?: IArea) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.storageId = _data["storageId"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(Product.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Area {
        data = typeof data === 'object' ? data : {};
        let result = new Area();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["storageId"] = this.storageId;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IArea extends IBaseAuditableEntity {
    name?: string;
    storageId?: number;
    products?: Product[];
}

export class Product extends BaseAuditableEntity implements IProduct {
    name?: string;
    units?: string;
    quantity?: number;
    soldQuantity?: number;
    orderedQuantity?: number;
    image?: string | undefined;
    status?: ProductStatus;
    expiration?: Date;
    importDate?: Date;
    exportDate?: Date;
    categoryId?: number;
    areaId?: number;
    category?: Category | undefined;
    area?: Area | undefined;
    storageId?: number;
    storage?: Storage | undefined;

    constructor(data?: IProduct) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.units = _data["units"];
            this.quantity = _data["quantity"];
            this.soldQuantity = _data["soldQuantity"];
            this.orderedQuantity = _data["orderedQuantity"];
            this.image = _data["image"];
            this.status = _data["status"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.importDate = _data["importDate"] ? new Date(_data["importDate"].toString()) : <any>undefined;
            this.exportDate = _data["exportDate"] ? new Date(_data["exportDate"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.areaId = _data["areaId"];
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
            this.area = _data["area"] ? Area.fromJS(_data["area"]) : <any>undefined;
            this.storageId = _data["storageId"];
            this.storage = _data["storage"] ? Storage.fromJS(_data["storage"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["units"] = this.units;
        data["quantity"] = this.quantity;
        data["soldQuantity"] = this.soldQuantity;
        data["orderedQuantity"] = this.orderedQuantity;
        data["image"] = this.image;
        data["status"] = this.status;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["importDate"] = this.importDate ? this.importDate.toISOString() : <any>undefined;
        data["exportDate"] = this.exportDate ? this.exportDate.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["areaId"] = this.areaId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["area"] = this.area ? this.area.toJSON() : <any>undefined;
        data["storageId"] = this.storageId;
        data["storage"] = this.storage ? this.storage.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IProduct extends IBaseAuditableEntity {
    name?: string;
    units?: string;
    quantity?: number;
    soldQuantity?: number;
    orderedQuantity?: number;
    image?: string | undefined;
    status?: ProductStatus;
    expiration?: Date;
    importDate?: Date;
    exportDate?: Date;
    categoryId?: number;
    areaId?: number;
    category?: Category | undefined;
    area?: Area | undefined;
    storageId?: number;
    storage?: Storage | undefined;
}

export enum ProductStatus {
    Available = 0,
    Sold = 1,
    Reserved = 2,
    Damaged = 3,
    Expired = 4,
}

export class Category extends BaseAuditableEntity implements ICategory {
    name?: string | undefined;
    companyId?: string | undefined;
    products?: Product[];

    constructor(data?: ICategory) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(Product.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICategory extends IBaseAuditableEntity {
    name?: string | undefined;
    companyId?: string | undefined;
    products?: Product[];
}

export abstract class BaseEvent implements IBaseEvent {

    constructor(data?: IBaseEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BaseEvent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEvent' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IBaseEvent {
}

export class Inventory extends BaseAuditableEntity implements IInventory {
    productName?: string;
    totalQuantity?: number;
    reservedQuantity?: number;
    availableQuantity?: number;
    expiration?: Date | undefined;
    totalPrice?: number;
    totalSalePrice?: number;
    safeStock?: number;
    categoryId?: number;
    storageId?: number;
    storage?: Storage | undefined;
    products?: Product[];

    constructor(data?: IInventory) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.productName = _data["productName"];
            this.totalQuantity = _data["totalQuantity"];
            this.reservedQuantity = _data["reservedQuantity"];
            this.availableQuantity = _data["availableQuantity"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.totalPrice = _data["totalPrice"];
            this.totalSalePrice = _data["totalSalePrice"];
            this.safeStock = _data["safeStock"];
            this.categoryId = _data["categoryId"];
            this.storageId = _data["storageId"];
            this.storage = _data["storage"] ? Storage.fromJS(_data["storage"]) : <any>undefined;
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(Product.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Inventory {
        data = typeof data === 'object' ? data : {};
        let result = new Inventory();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productName"] = this.productName;
        data["totalQuantity"] = this.totalQuantity;
        data["reservedQuantity"] = this.reservedQuantity;
        data["availableQuantity"] = this.availableQuantity;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["totalPrice"] = this.totalPrice;
        data["totalSalePrice"] = this.totalSalePrice;
        data["safeStock"] = this.safeStock;
        data["categoryId"] = this.categoryId;
        data["storageId"] = this.storageId;
        data["storage"] = this.storage ? this.storage.toJSON() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IInventory extends IBaseAuditableEntity {
    productName?: string;
    totalQuantity?: number;
    reservedQuantity?: number;
    availableQuantity?: number;
    expiration?: Date | undefined;
    totalPrice?: number;
    totalSalePrice?: number;
    safeStock?: number;
    categoryId?: number;
    storageId?: number;
    storage?: Storage | undefined;
    products?: Product[];
}

export class UserStorage extends BaseAuditableEntity implements IUserStorage {
    userId?: string;
    storageId?: number;
    storage?: Storage;

    constructor(data?: IUserStorage) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
            this.storageId = _data["storageId"];
            this.storage = _data["storage"] ? Storage.fromJS(_data["storage"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): UserStorage {
        data = typeof data === 'object' ? data : {};
        let result = new UserStorage();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["storageId"] = this.storageId;
        data["storage"] = this.storage ? this.storage.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IUserStorage extends IBaseAuditableEntity {
    userId?: string;
    storageId?: number;
    storage?: Storage;
}

export class Page implements IPage {
    size?: number;
    pageNumber?: number;
    totalElements?: number;
    totalPages?: number;
    sortBy?: string;
    sortAsc?: boolean;

    constructor(data?: IPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.size = _data["size"];
            this.pageNumber = _data["pageNumber"];
            this.totalElements = _data["totalElements"];
            this.totalPages = _data["totalPages"];
            this.sortBy = _data["sortBy"];
            this.sortAsc = _data["sortAsc"];
        }
    }

    static fromJS(data: any): Page {
        data = typeof data === 'object' ? data : {};
        let result = new Page();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["size"] = this.size;
        data["pageNumber"] = this.pageNumber;
        data["totalElements"] = this.totalElements;
        data["totalPages"] = this.totalPages;
        data["sortBy"] = this.sortBy;
        data["sortAsc"] = this.sortAsc;
        return data;
    }
}

export interface IPage {
    size?: number;
    pageNumber?: number;
    totalElements?: number;
    totalPages?: number;
    sortBy?: string;
    sortAsc?: boolean;
}

export class GetCompanyOwnerListQuery implements IGetCompanyOwnerListQuery {
    page?: Page | undefined;

    constructor(data?: IGetCompanyOwnerListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCompanyOwnerListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCompanyOwnerListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCompanyOwnerListQuery {
    page?: Page | undefined;
}

export class CompanyOwnerDetailDto implements ICompanyOwnerDetailDto {
    compayOwnerId?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    companyName?: string | undefined;
    companyId?: string | undefined;
    companyPhone?: string | undefined;
    companyEmail?: string | undefined;
    companyAddress?: string | undefined;
    storages?: StorageDto[] | undefined;
    imageFile?: string | undefined;

    constructor(data?: ICompanyOwnerDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.compayOwnerId = _data["compayOwnerId"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.companyName = _data["companyName"];
            this.companyId = _data["companyId"];
            this.companyPhone = _data["companyPhone"];
            this.companyEmail = _data["companyEmail"];
            this.companyAddress = _data["companyAddress"];
            if (Array.isArray(_data["storages"])) {
                this.storages = [] as any;
                for (let item of _data["storages"])
                    this.storages!.push(StorageDto.fromJS(item));
            }
            this.imageFile = _data["imageFile"];
        }
    }

    static fromJS(data: any): CompanyOwnerDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyOwnerDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["compayOwnerId"] = this.compayOwnerId;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["companyName"] = this.companyName;
        data["companyId"] = this.companyId;
        data["companyPhone"] = this.companyPhone;
        data["companyEmail"] = this.companyEmail;
        data["companyAddress"] = this.companyAddress;
        if (Array.isArray(this.storages)) {
            data["storages"] = [];
            for (let item of this.storages)
                data["storages"].push(item.toJSON());
        }
        data["imageFile"] = this.imageFile;
        return data;
    }
}

export interface ICompanyOwnerDetailDto {
    compayOwnerId?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    companyName?: string | undefined;
    companyId?: string | undefined;
    companyPhone?: string | undefined;
    companyEmail?: string | undefined;
    companyAddress?: string | undefined;
    storages?: StorageDto[] | undefined;
    imageFile?: string | undefined;
}

export class StorageDto implements IStorageDto {
    id?: number;
    name?: string | undefined;
    location?: string | undefined;
    status?: StorageStatus | undefined;
    areas?: AreaDto[] | undefined;

    constructor(data?: IStorageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.location = _data["location"];
            this.status = _data["status"];
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(AreaDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StorageDto {
        data = typeof data === 'object' ? data : {};
        let result = new StorageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["location"] = this.location;
        data["status"] = this.status;
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStorageDto {
    id?: number;
    name?: string | undefined;
    location?: string | undefined;
    status?: StorageStatus | undefined;
    areas?: AreaDto[] | undefined;
}

export class AreaDto implements IAreaDto {
    name?: string | undefined;

    constructor(data?: IAreaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AreaDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IAreaDto {
    name?: string | undefined;
}

export class UpdateCompanyOwnerCommand implements IUpdateCompanyOwnerCommand {
    userId?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    companyId?: string | undefined;
    storages?: StorageDto[] | undefined;
    avatarImage?: string | undefined;

    constructor(data?: IUpdateCompanyOwnerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["storages"])) {
                this.storages = [] as any;
                for (let item of _data["storages"])
                    this.storages!.push(StorageDto.fromJS(item));
            }
            this.avatarImage = _data["avatarImage"];
        }
    }

    static fromJS(data: any): UpdateCompanyOwnerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyOwnerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["companyId"] = this.companyId;
        if (Array.isArray(this.storages)) {
            data["storages"] = [];
            for (let item of this.storages)
                data["storages"].push(item.toJSON());
        }
        data["avatarImage"] = this.avatarImage;
        return data;
    }
}

export interface IUpdateCompanyOwnerCommand {
    userId?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    companyId?: string | undefined;
    storages?: StorageDto[] | undefined;
    avatarImage?: string | undefined;
}

export class CreateConfigCommand implements ICreateConfigCommand {
    aiServiceKey?: string | undefined;
    emailServiceKey?: string | undefined;
    aiDriverServer?: string | undefined;

    constructor(data?: ICreateConfigCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aiServiceKey = _data["aiServiceKey"];
            this.emailServiceKey = _data["emailServiceKey"];
            this.aiDriverServer = _data["aiDriverServer"];
        }
    }

    static fromJS(data: any): CreateConfigCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateConfigCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aiServiceKey"] = this.aiServiceKey;
        data["emailServiceKey"] = this.emailServiceKey;
        data["aiDriverServer"] = this.aiDriverServer;
        return data;
    }
}

export interface ICreateConfigCommand {
    aiServiceKey?: string | undefined;
    emailServiceKey?: string | undefined;
    aiDriverServer?: string | undefined;
}

export class ConfigVm implements IConfigVm {
    aiServiceKey?: string | undefined;
    emailServiceKey?: string | undefined;
    aiDriverServer?: string | undefined;

    constructor(data?: IConfigVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aiServiceKey = _data["aiServiceKey"];
            this.emailServiceKey = _data["emailServiceKey"];
            this.aiDriverServer = _data["aiDriverServer"];
        }
    }

    static fromJS(data: any): ConfigVm {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aiServiceKey"] = this.aiServiceKey;
        data["emailServiceKey"] = this.emailServiceKey;
        data["aiDriverServer"] = this.aiDriverServer;
        return data;
    }
}

export interface IConfigVm {
    aiServiceKey?: string | undefined;
    emailServiceKey?: string | undefined;
    aiDriverServer?: string | undefined;
}

export class CommodityLinks implements ICommodityLinks {
    crudeOil?: string[];
    brent?: string[];
    naturalGas?: string[];
    gasoline?: string[];
    heatingOil?: string[];
    coal?: string[];
    ttfGas?: string[];
    ukGas?: string[];
    ethanol?: string[];
    naphtha?: string[];
    propane?: string[];
    methanol?: string[];
    uralsOil?: string[];
    gold?: string[];
    silver?: string[];
    copper?: string[];
    steel?: string[];
    ironOre?: string[];
    platinum?: string[];
    titanium?: string[];
    hrcSteel?: string[];
    soybeans?: string[];
    wheat?: string[];
    lumber?: string[];
    palmOil?: string[];
    cheese?: string[];
    milk?: string[];
    rubber?: string[];
    orangeJuice?: string[];
    coffee?: string[];
    cotton?: string[];
    cocoa?: string[];
    rice?: string[];
    canola?: string[];
    oat?: string[];
    wool?: string[];
    sugar?: string[];
    sunflowerOil?: string[];
    rapeseed?: string[];
    butter?: string[];
    potatoes?: string[];
    corn?: string[];
    feederCattle?: string[];
    liveCattle?: string[];
    leanHogs?: string[];
    beef?: string[];
    poultry?: string[];
    eggsCH?: string[];
    salmon?: string[];

    constructor(data?: ICommodityLinks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["crudeOil"])) {
                this.crudeOil = [] as any;
                for (let item of _data["crudeOil"])
                    this.crudeOil!.push(item);
            }
            if (Array.isArray(_data["brent"])) {
                this.brent = [] as any;
                for (let item of _data["brent"])
                    this.brent!.push(item);
            }
            if (Array.isArray(_data["naturalGas"])) {
                this.naturalGas = [] as any;
                for (let item of _data["naturalGas"])
                    this.naturalGas!.push(item);
            }
            if (Array.isArray(_data["gasoline"])) {
                this.gasoline = [] as any;
                for (let item of _data["gasoline"])
                    this.gasoline!.push(item);
            }
            if (Array.isArray(_data["heatingOil"])) {
                this.heatingOil = [] as any;
                for (let item of _data["heatingOil"])
                    this.heatingOil!.push(item);
            }
            if (Array.isArray(_data["coal"])) {
                this.coal = [] as any;
                for (let item of _data["coal"])
                    this.coal!.push(item);
            }
            if (Array.isArray(_data["ttfGas"])) {
                this.ttfGas = [] as any;
                for (let item of _data["ttfGas"])
                    this.ttfGas!.push(item);
            }
            if (Array.isArray(_data["ukGas"])) {
                this.ukGas = [] as any;
                for (let item of _data["ukGas"])
                    this.ukGas!.push(item);
            }
            if (Array.isArray(_data["ethanol"])) {
                this.ethanol = [] as any;
                for (let item of _data["ethanol"])
                    this.ethanol!.push(item);
            }
            if (Array.isArray(_data["naphtha"])) {
                this.naphtha = [] as any;
                for (let item of _data["naphtha"])
                    this.naphtha!.push(item);
            }
            if (Array.isArray(_data["propane"])) {
                this.propane = [] as any;
                for (let item of _data["propane"])
                    this.propane!.push(item);
            }
            if (Array.isArray(_data["methanol"])) {
                this.methanol = [] as any;
                for (let item of _data["methanol"])
                    this.methanol!.push(item);
            }
            if (Array.isArray(_data["uralsOil"])) {
                this.uralsOil = [] as any;
                for (let item of _data["uralsOil"])
                    this.uralsOil!.push(item);
            }
            if (Array.isArray(_data["gold"])) {
                this.gold = [] as any;
                for (let item of _data["gold"])
                    this.gold!.push(item);
            }
            if (Array.isArray(_data["silver"])) {
                this.silver = [] as any;
                for (let item of _data["silver"])
                    this.silver!.push(item);
            }
            if (Array.isArray(_data["copper"])) {
                this.copper = [] as any;
                for (let item of _data["copper"])
                    this.copper!.push(item);
            }
            if (Array.isArray(_data["steel"])) {
                this.steel = [] as any;
                for (let item of _data["steel"])
                    this.steel!.push(item);
            }
            if (Array.isArray(_data["ironOre"])) {
                this.ironOre = [] as any;
                for (let item of _data["ironOre"])
                    this.ironOre!.push(item);
            }
            if (Array.isArray(_data["platinum"])) {
                this.platinum = [] as any;
                for (let item of _data["platinum"])
                    this.platinum!.push(item);
            }
            if (Array.isArray(_data["titanium"])) {
                this.titanium = [] as any;
                for (let item of _data["titanium"])
                    this.titanium!.push(item);
            }
            if (Array.isArray(_data["hrcSteel"])) {
                this.hrcSteel = [] as any;
                for (let item of _data["hrcSteel"])
                    this.hrcSteel!.push(item);
            }
            if (Array.isArray(_data["soybeans"])) {
                this.soybeans = [] as any;
                for (let item of _data["soybeans"])
                    this.soybeans!.push(item);
            }
            if (Array.isArray(_data["wheat"])) {
                this.wheat = [] as any;
                for (let item of _data["wheat"])
                    this.wheat!.push(item);
            }
            if (Array.isArray(_data["lumber"])) {
                this.lumber = [] as any;
                for (let item of _data["lumber"])
                    this.lumber!.push(item);
            }
            if (Array.isArray(_data["palmOil"])) {
                this.palmOil = [] as any;
                for (let item of _data["palmOil"])
                    this.palmOil!.push(item);
            }
            if (Array.isArray(_data["cheese"])) {
                this.cheese = [] as any;
                for (let item of _data["cheese"])
                    this.cheese!.push(item);
            }
            if (Array.isArray(_data["milk"])) {
                this.milk = [] as any;
                for (let item of _data["milk"])
                    this.milk!.push(item);
            }
            if (Array.isArray(_data["rubber"])) {
                this.rubber = [] as any;
                for (let item of _data["rubber"])
                    this.rubber!.push(item);
            }
            if (Array.isArray(_data["orangeJuice"])) {
                this.orangeJuice = [] as any;
                for (let item of _data["orangeJuice"])
                    this.orangeJuice!.push(item);
            }
            if (Array.isArray(_data["coffee"])) {
                this.coffee = [] as any;
                for (let item of _data["coffee"])
                    this.coffee!.push(item);
            }
            if (Array.isArray(_data["cotton"])) {
                this.cotton = [] as any;
                for (let item of _data["cotton"])
                    this.cotton!.push(item);
            }
            if (Array.isArray(_data["cocoa"])) {
                this.cocoa = [] as any;
                for (let item of _data["cocoa"])
                    this.cocoa!.push(item);
            }
            if (Array.isArray(_data["rice"])) {
                this.rice = [] as any;
                for (let item of _data["rice"])
                    this.rice!.push(item);
            }
            if (Array.isArray(_data["canola"])) {
                this.canola = [] as any;
                for (let item of _data["canola"])
                    this.canola!.push(item);
            }
            if (Array.isArray(_data["oat"])) {
                this.oat = [] as any;
                for (let item of _data["oat"])
                    this.oat!.push(item);
            }
            if (Array.isArray(_data["wool"])) {
                this.wool = [] as any;
                for (let item of _data["wool"])
                    this.wool!.push(item);
            }
            if (Array.isArray(_data["sugar"])) {
                this.sugar = [] as any;
                for (let item of _data["sugar"])
                    this.sugar!.push(item);
            }
            if (Array.isArray(_data["sunflowerOil"])) {
                this.sunflowerOil = [] as any;
                for (let item of _data["sunflowerOil"])
                    this.sunflowerOil!.push(item);
            }
            if (Array.isArray(_data["rapeseed"])) {
                this.rapeseed = [] as any;
                for (let item of _data["rapeseed"])
                    this.rapeseed!.push(item);
            }
            if (Array.isArray(_data["butter"])) {
                this.butter = [] as any;
                for (let item of _data["butter"])
                    this.butter!.push(item);
            }
            if (Array.isArray(_data["potatoes"])) {
                this.potatoes = [] as any;
                for (let item of _data["potatoes"])
                    this.potatoes!.push(item);
            }
            if (Array.isArray(_data["corn"])) {
                this.corn = [] as any;
                for (let item of _data["corn"])
                    this.corn!.push(item);
            }
            if (Array.isArray(_data["feederCattle"])) {
                this.feederCattle = [] as any;
                for (let item of _data["feederCattle"])
                    this.feederCattle!.push(item);
            }
            if (Array.isArray(_data["liveCattle"])) {
                this.liveCattle = [] as any;
                for (let item of _data["liveCattle"])
                    this.liveCattle!.push(item);
            }
            if (Array.isArray(_data["leanHogs"])) {
                this.leanHogs = [] as any;
                for (let item of _data["leanHogs"])
                    this.leanHogs!.push(item);
            }
            if (Array.isArray(_data["beef"])) {
                this.beef = [] as any;
                for (let item of _data["beef"])
                    this.beef!.push(item);
            }
            if (Array.isArray(_data["poultry"])) {
                this.poultry = [] as any;
                for (let item of _data["poultry"])
                    this.poultry!.push(item);
            }
            if (Array.isArray(_data["eggsCH"])) {
                this.eggsCH = [] as any;
                for (let item of _data["eggsCH"])
                    this.eggsCH!.push(item);
            }
            if (Array.isArray(_data["salmon"])) {
                this.salmon = [] as any;
                for (let item of _data["salmon"])
                    this.salmon!.push(item);
            }
        }
    }

    static fromJS(data: any): CommodityLinks {
        data = typeof data === 'object' ? data : {};
        let result = new CommodityLinks();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.crudeOil)) {
            data["crudeOil"] = [];
            for (let item of this.crudeOil)
                data["crudeOil"].push(item);
        }
        if (Array.isArray(this.brent)) {
            data["brent"] = [];
            for (let item of this.brent)
                data["brent"].push(item);
        }
        if (Array.isArray(this.naturalGas)) {
            data["naturalGas"] = [];
            for (let item of this.naturalGas)
                data["naturalGas"].push(item);
        }
        if (Array.isArray(this.gasoline)) {
            data["gasoline"] = [];
            for (let item of this.gasoline)
                data["gasoline"].push(item);
        }
        if (Array.isArray(this.heatingOil)) {
            data["heatingOil"] = [];
            for (let item of this.heatingOil)
                data["heatingOil"].push(item);
        }
        if (Array.isArray(this.coal)) {
            data["coal"] = [];
            for (let item of this.coal)
                data["coal"].push(item);
        }
        if (Array.isArray(this.ttfGas)) {
            data["ttfGas"] = [];
            for (let item of this.ttfGas)
                data["ttfGas"].push(item);
        }
        if (Array.isArray(this.ukGas)) {
            data["ukGas"] = [];
            for (let item of this.ukGas)
                data["ukGas"].push(item);
        }
        if (Array.isArray(this.ethanol)) {
            data["ethanol"] = [];
            for (let item of this.ethanol)
                data["ethanol"].push(item);
        }
        if (Array.isArray(this.naphtha)) {
            data["naphtha"] = [];
            for (let item of this.naphtha)
                data["naphtha"].push(item);
        }
        if (Array.isArray(this.propane)) {
            data["propane"] = [];
            for (let item of this.propane)
                data["propane"].push(item);
        }
        if (Array.isArray(this.methanol)) {
            data["methanol"] = [];
            for (let item of this.methanol)
                data["methanol"].push(item);
        }
        if (Array.isArray(this.uralsOil)) {
            data["uralsOil"] = [];
            for (let item of this.uralsOil)
                data["uralsOil"].push(item);
        }
        if (Array.isArray(this.gold)) {
            data["gold"] = [];
            for (let item of this.gold)
                data["gold"].push(item);
        }
        if (Array.isArray(this.silver)) {
            data["silver"] = [];
            for (let item of this.silver)
                data["silver"].push(item);
        }
        if (Array.isArray(this.copper)) {
            data["copper"] = [];
            for (let item of this.copper)
                data["copper"].push(item);
        }
        if (Array.isArray(this.steel)) {
            data["steel"] = [];
            for (let item of this.steel)
                data["steel"].push(item);
        }
        if (Array.isArray(this.ironOre)) {
            data["ironOre"] = [];
            for (let item of this.ironOre)
                data["ironOre"].push(item);
        }
        if (Array.isArray(this.platinum)) {
            data["platinum"] = [];
            for (let item of this.platinum)
                data["platinum"].push(item);
        }
        if (Array.isArray(this.titanium)) {
            data["titanium"] = [];
            for (let item of this.titanium)
                data["titanium"].push(item);
        }
        if (Array.isArray(this.hrcSteel)) {
            data["hrcSteel"] = [];
            for (let item of this.hrcSteel)
                data["hrcSteel"].push(item);
        }
        if (Array.isArray(this.soybeans)) {
            data["soybeans"] = [];
            for (let item of this.soybeans)
                data["soybeans"].push(item);
        }
        if (Array.isArray(this.wheat)) {
            data["wheat"] = [];
            for (let item of this.wheat)
                data["wheat"].push(item);
        }
        if (Array.isArray(this.lumber)) {
            data["lumber"] = [];
            for (let item of this.lumber)
                data["lumber"].push(item);
        }
        if (Array.isArray(this.palmOil)) {
            data["palmOil"] = [];
            for (let item of this.palmOil)
                data["palmOil"].push(item);
        }
        if (Array.isArray(this.cheese)) {
            data["cheese"] = [];
            for (let item of this.cheese)
                data["cheese"].push(item);
        }
        if (Array.isArray(this.milk)) {
            data["milk"] = [];
            for (let item of this.milk)
                data["milk"].push(item);
        }
        if (Array.isArray(this.rubber)) {
            data["rubber"] = [];
            for (let item of this.rubber)
                data["rubber"].push(item);
        }
        if (Array.isArray(this.orangeJuice)) {
            data["orangeJuice"] = [];
            for (let item of this.orangeJuice)
                data["orangeJuice"].push(item);
        }
        if (Array.isArray(this.coffee)) {
            data["coffee"] = [];
            for (let item of this.coffee)
                data["coffee"].push(item);
        }
        if (Array.isArray(this.cotton)) {
            data["cotton"] = [];
            for (let item of this.cotton)
                data["cotton"].push(item);
        }
        if (Array.isArray(this.cocoa)) {
            data["cocoa"] = [];
            for (let item of this.cocoa)
                data["cocoa"].push(item);
        }
        if (Array.isArray(this.rice)) {
            data["rice"] = [];
            for (let item of this.rice)
                data["rice"].push(item);
        }
        if (Array.isArray(this.canola)) {
            data["canola"] = [];
            for (let item of this.canola)
                data["canola"].push(item);
        }
        if (Array.isArray(this.oat)) {
            data["oat"] = [];
            for (let item of this.oat)
                data["oat"].push(item);
        }
        if (Array.isArray(this.wool)) {
            data["wool"] = [];
            for (let item of this.wool)
                data["wool"].push(item);
        }
        if (Array.isArray(this.sugar)) {
            data["sugar"] = [];
            for (let item of this.sugar)
                data["sugar"].push(item);
        }
        if (Array.isArray(this.sunflowerOil)) {
            data["sunflowerOil"] = [];
            for (let item of this.sunflowerOil)
                data["sunflowerOil"].push(item);
        }
        if (Array.isArray(this.rapeseed)) {
            data["rapeseed"] = [];
            for (let item of this.rapeseed)
                data["rapeseed"].push(item);
        }
        if (Array.isArray(this.butter)) {
            data["butter"] = [];
            for (let item of this.butter)
                data["butter"].push(item);
        }
        if (Array.isArray(this.potatoes)) {
            data["potatoes"] = [];
            for (let item of this.potatoes)
                data["potatoes"].push(item);
        }
        if (Array.isArray(this.corn)) {
            data["corn"] = [];
            for (let item of this.corn)
                data["corn"].push(item);
        }
        if (Array.isArray(this.feederCattle)) {
            data["feederCattle"] = [];
            for (let item of this.feederCattle)
                data["feederCattle"].push(item);
        }
        if (Array.isArray(this.liveCattle)) {
            data["liveCattle"] = [];
            for (let item of this.liveCattle)
                data["liveCattle"].push(item);
        }
        if (Array.isArray(this.leanHogs)) {
            data["leanHogs"] = [];
            for (let item of this.leanHogs)
                data["leanHogs"].push(item);
        }
        if (Array.isArray(this.beef)) {
            data["beef"] = [];
            for (let item of this.beef)
                data["beef"].push(item);
        }
        if (Array.isArray(this.poultry)) {
            data["poultry"] = [];
            for (let item of this.poultry)
                data["poultry"].push(item);
        }
        if (Array.isArray(this.eggsCH)) {
            data["eggsCH"] = [];
            for (let item of this.eggsCH)
                data["eggsCH"].push(item);
        }
        if (Array.isArray(this.salmon)) {
            data["salmon"] = [];
            for (let item of this.salmon)
                data["salmon"].push(item);
        }
        return data;
    }
}

export interface ICommodityLinks {
    crudeOil?: string[];
    brent?: string[];
    naturalGas?: string[];
    gasoline?: string[];
    heatingOil?: string[];
    coal?: string[];
    ttfGas?: string[];
    ukGas?: string[];
    ethanol?: string[];
    naphtha?: string[];
    propane?: string[];
    methanol?: string[];
    uralsOil?: string[];
    gold?: string[];
    silver?: string[];
    copper?: string[];
    steel?: string[];
    ironOre?: string[];
    platinum?: string[];
    titanium?: string[];
    hrcSteel?: string[];
    soybeans?: string[];
    wheat?: string[];
    lumber?: string[];
    palmOil?: string[];
    cheese?: string[];
    milk?: string[];
    rubber?: string[];
    orangeJuice?: string[];
    coffee?: string[];
    cotton?: string[];
    cocoa?: string[];
    rice?: string[];
    canola?: string[];
    oat?: string[];
    wool?: string[];
    sugar?: string[];
    sunflowerOil?: string[];
    rapeseed?: string[];
    butter?: string[];
    potatoes?: string[];
    corn?: string[];
    feederCattle?: string[];
    liveCattle?: string[];
    leanHogs?: string[];
    beef?: string[];
    poultry?: string[];
    eggsCH?: string[];
    salmon?: string[];
}

export class CrawlResponse implements ICrawlResponse {
    unixTimeNow?: number;
    dateNow?: string | undefined;
    data?: CrawlData[] | undefined;

    constructor(data?: ICrawlResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unixTimeNow = _data["unixTimeNow"];
            this.dateNow = _data["dateNow"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CrawlData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CrawlResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CrawlResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unixTimeNow"] = this.unixTimeNow;
        data["dateNow"] = this.dateNow;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICrawlResponse {
    unixTimeNow?: number;
    dateNow?: string | undefined;
    data?: CrawlData[] | undefined;
}

export class CrawlData implements ICrawlData {
    index?: number;
    date?: string | undefined;
    unixDateMs?: number;
    value?: number;

    constructor(data?: ICrawlData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            this.date = _data["date"];
            this.unixDateMs = _data["unixDateMs"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CrawlData {
        data = typeof data === 'object' ? data : {};
        let result = new CrawlData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["date"] = this.date;
        data["unixDateMs"] = this.unixDateMs;
        data["value"] = this.value;
        return data;
    }
}

export interface ICrawlData {
    index?: number;
    date?: string | undefined;
    unixDateMs?: number;
    value?: number;
}

export class CreateCustomerCommand implements ICreateCustomerCommand {
    name?: string;
    email?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;

    constructor(data?: ICreateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): CreateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address;
        return data;
    }
}

export interface ICreateCustomerCommand {
    name?: string;
    email?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
}

export class CustomersVM implements ICustomersVM {
    customers?: CustomerDto[];

    constructor(data?: ICustomersVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["customers"])) {
                this.customers = [] as any;
                for (let item of _data["customers"])
                    this.customers!.push(CustomerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomersVM {
        data = typeof data === 'object' ? data : {};
        let result = new CustomersVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customers)) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomersVM {
    customers?: CustomerDto[];
}

export class CustomerDto implements ICustomerDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICustomerDto {
    id?: number;
    name?: string | undefined;
}

export class UpdateCustomerCommand implements IUpdateCustomerCommand {
    customerId?: number;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;

    constructor(data?: IUpdateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): UpdateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address;
        return data;
    }
}

export interface IUpdateCustomerCommand {
    customerId?: number;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
}

export class CustomerDetailDto implements ICustomerDetailDto {
    id?: number;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    isActive?: boolean;

    constructor(data?: ICustomerDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CustomerDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICustomerDetailDto {
    id?: number;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    isActive?: boolean;
}

export class CreateEmployeeCommand implements ICreateEmployeeCommand {
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    warehouses?: number[] | undefined;

    constructor(data?: ICreateEmployeeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            if (Array.isArray(_data["warehouses"])) {
                this.warehouses = [] as any;
                for (let item of _data["warehouses"])
                    this.warehouses!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateEmployeeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEmployeeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        if (Array.isArray(this.warehouses)) {
            data["warehouses"] = [];
            for (let item of this.warehouses)
                data["warehouses"].push(item);
        }
        return data;
    }
}

export interface ICreateEmployeeCommand {
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    warehouses?: number[] | undefined;
}

export class UpdateEmployeeCommand implements IUpdateEmployeeCommand {
    id?: string;
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    warehouses?: number[] | undefined;

    constructor(data?: IUpdateEmployeeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            if (Array.isArray(_data["warehouses"])) {
                this.warehouses = [] as any;
                for (let item of _data["warehouses"])
                    this.warehouses!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateEmployeeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEmployeeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        if (Array.isArray(this.warehouses)) {
            data["warehouses"] = [];
            for (let item of this.warehouses)
                data["warehouses"].push(item);
        }
        return data;
    }
}

export interface IUpdateEmployeeCommand {
    id?: string;
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    warehouses?: number[] | undefined;
}

export class EmployeeListVM implements IEmployeeListVM {
    employees?: EmployeeDto[] | undefined;
    page?: Page | undefined;

    constructor(data?: IEmployeeListVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(EmployeeDto.fromJS(item));
            }
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EmployeeListVM {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeListVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEmployeeListVM {
    employees?: EmployeeDto[] | undefined;
    page?: Page | undefined;
}

export class EmployeeDto implements IEmployeeDto {
    id?: string | undefined;
    companyId?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    isActived?: boolean;
    avatarImage?: string | undefined;

    constructor(data?: IEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActived = _data["isActived"];
            this.avatarImage = _data["avatarImage"];
        }
    }

    static fromJS(data: any): EmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["isActived"] = this.isActived;
        data["avatarImage"] = this.avatarImage;
        return data;
    }
}

export interface IEmployeeDto {
    id?: string | undefined;
    companyId?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    isActived?: boolean;
    avatarImage?: string | undefined;
}

export class GetListEmployeeQuery implements IGetListEmployeeQuery {
    page?: Page | undefined;
    filterData?: FilterData[] | undefined;

    constructor(data?: IGetListEmployeeQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
            if (Array.isArray(_data["filterData"])) {
                this.filterData = [] as any;
                for (let item of _data["filterData"])
                    this.filterData!.push(FilterData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetListEmployeeQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetListEmployeeQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        if (Array.isArray(this.filterData)) {
            data["filterData"] = [];
            for (let item of this.filterData)
                data["filterData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetListEmployeeQuery {
    page?: Page | undefined;
    filterData?: FilterData[] | undefined;
}

export class FilterData implements IFilterData {
    prop?: string;
    value?: string;
    filter?: string;
    type?: string;

    constructor(data?: IFilterData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.prop = _data["prop"];
            this.value = _data["value"];
            this.filter = _data["filter"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): FilterData {
        data = typeof data === 'object' ? data : {};
        let result = new FilterData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prop"] = this.prop;
        data["value"] = this.value;
        data["filter"] = this.filter;
        data["type"] = this.type;
        return data;
    }
}

export interface IFilterData {
    prop?: string;
    value?: string;
    filter?: string;
    type?: string;
}

export class EmployeeDetailVM implements IEmployeeDetailVM {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    companyId?: string | undefined;
    companyName?: string | undefined;
    companyPhone?: string | undefined;
    companyEmail?: string | undefined;
    companyAddress?: string | undefined;
    storages?: StorageDto2[] | undefined;

    constructor(data?: IEmployeeDetailVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.companyPhone = _data["companyPhone"];
            this.companyEmail = _data["companyEmail"];
            this.companyAddress = _data["companyAddress"];
            if (Array.isArray(_data["storages"])) {
                this.storages = [] as any;
                for (let item of _data["storages"])
                    this.storages!.push(StorageDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmployeeDetailVM {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDetailVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["companyPhone"] = this.companyPhone;
        data["companyEmail"] = this.companyEmail;
        data["companyAddress"] = this.companyAddress;
        if (Array.isArray(this.storages)) {
            data["storages"] = [];
            for (let item of this.storages)
                data["storages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEmployeeDetailVM {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    companyId?: string | undefined;
    companyName?: string | undefined;
    companyPhone?: string | undefined;
    companyEmail?: string | undefined;
    companyAddress?: string | undefined;
    storages?: StorageDto2[] | undefined;
}

export class StorageDto2 implements IStorageDto2 {
    id?: number;
    name?: string | undefined;
    address?: string | undefined;
    status?: string | undefined;
    areas?: AreaDto2[] | undefined;

    constructor(data?: IStorageDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.status = _data["status"];
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(AreaDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StorageDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new StorageDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["address"] = this.address;
        data["status"] = this.status;
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStorageDto2 {
    id?: number;
    name?: string | undefined;
    address?: string | undefined;
    status?: string | undefined;
    areas?: AreaDto2[] | undefined;
}

export class AreaDto2 implements IAreaDto2 {
    id?: number;
    name?: string;

    constructor(data?: IAreaDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AreaDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new AreaDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IAreaDto2 {
    id?: number;
    name?: string;
}

export class SignInVm implements ISignInVm {
    token?: string | undefined;
    statusCode?: number;

    constructor(data?: ISignInVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): SignInVm {
        data = typeof data === 'object' ? data : {};
        let result = new SignInVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface ISignInVm {
    token?: string | undefined;
    statusCode?: number;
}

export class SignInCommand implements ISignInCommand {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: ISignInCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): SignInCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SignInCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ISignInCommand {
    email?: string | undefined;
    password?: string | undefined;
}

export class ResetPasswordVm implements IResetPasswordVm {
    token?: string;
    statusCode?: number;

    constructor(data?: IResetPasswordVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): ResetPasswordVm {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IResetPasswordVm {
    token?: string;
    statusCode?: number;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    email?: string;
    currentPassword?: string;
    newPassword?: string;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordCommand {
    email?: string;
    currentPassword?: string;
    newPassword?: string;
}

export class InventoryProductsListVM implements IInventoryProductsListVM {
    products?: InventoryProductsDto[] | undefined;
    page?: Page | undefined;

    constructor(data?: IInventoryProductsListVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(InventoryProductsDto.fromJS(item));
            }
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InventoryProductsListVM {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryProductsListVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInventoryProductsListVM {
    products?: InventoryProductsDto[] | undefined;
    page?: Page | undefined;
}

export class InventoryProductsDto implements IInventoryProductsDto {
    id?: number;
    productName?: string;
    totalQuantity?: number;
    availableQuantity?: number;
    expiration?: Date | undefined;
    totalPrice?: number;
    safeStock?: number;
    categoryId?: number;
    storageId?: number;
    storageName?: string;

    constructor(data?: IInventoryProductsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productName = _data["productName"];
            this.totalQuantity = _data["totalQuantity"];
            this.availableQuantity = _data["availableQuantity"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.totalPrice = _data["totalPrice"];
            this.safeStock = _data["safeStock"];
            this.categoryId = _data["categoryId"];
            this.storageId = _data["storageId"];
            this.storageName = _data["storageName"];
        }
    }

    static fromJS(data: any): InventoryProductsDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryProductsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productName"] = this.productName;
        data["totalQuantity"] = this.totalQuantity;
        data["availableQuantity"] = this.availableQuantity;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["totalPrice"] = this.totalPrice;
        data["safeStock"] = this.safeStock;
        data["categoryId"] = this.categoryId;
        data["storageId"] = this.storageId;
        data["storageName"] = this.storageName;
        return data;
    }
}

export interface IInventoryProductsDto {
    id?: number;
    productName?: string;
    totalQuantity?: number;
    availableQuantity?: number;
    expiration?: Date | undefined;
    totalPrice?: number;
    safeStock?: number;
    categoryId?: number;
    storageId?: number;
    storageName?: string;
}

export class GetListProductOfInventory implements IGetListProductOfInventory {
    page?: Page | undefined;

    constructor(data?: IGetListProductOfInventory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetListProductOfInventory {
        data = typeof data === 'object' ? data : {};
        let result = new GetListProductOfInventory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetListProductOfInventory {
    page?: Page | undefined;
}

export class InventoryListVM implements IInventoryListVM {
    page?: Page | undefined;
    inventories?: InventoryDto[] | undefined;

    constructor(data?: IInventoryListVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
            if (Array.isArray(_data["inventories"])) {
                this.inventories = [] as any;
                for (let item of _data["inventories"])
                    this.inventories!.push(InventoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InventoryListVM {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryListVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        if (Array.isArray(this.inventories)) {
            data["inventories"] = [];
            for (let item of this.inventories)
                data["inventories"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInventoryListVM {
    page?: Page | undefined;
    inventories?: InventoryDto[] | undefined;
}

export class InventoryDto implements IInventoryDto {
    productName?: string;
    availableQuantity?: number;
    expiration?: Date | undefined;
    totalPrice?: number;
    totalSalePrice?: number;
    safeStock?: number;
    status?: string;

    constructor(data?: IInventoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productName = _data["productName"];
            this.availableQuantity = _data["availableQuantity"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.totalPrice = _data["totalPrice"];
            this.totalSalePrice = _data["totalSalePrice"];
            this.safeStock = _data["safeStock"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): InventoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productName"] = this.productName;
        data["availableQuantity"] = this.availableQuantity;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["totalPrice"] = this.totalPrice;
        data["totalSalePrice"] = this.totalSalePrice;
        data["safeStock"] = this.safeStock;
        data["status"] = this.status;
        return data;
    }
}

export interface IInventoryDto {
    productName?: string;
    availableQuantity?: number;
    expiration?: Date | undefined;
    totalPrice?: number;
    totalSalePrice?: number;
    safeStock?: number;
    status?: string;
}

export class GetInventoriesByStorageQuery implements IGetInventoriesByStorageQuery {
    storageId?: number;
    page?: Page;
    filters?: FilterData[] | undefined;

    constructor(data?: IGetInventoriesByStorageQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storageId = _data["storageId"];
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(FilterData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetInventoriesByStorageQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetInventoriesByStorageQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storageId"] = this.storageId;
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetInventoriesByStorageQuery {
    storageId?: number;
    page?: Page;
    filters?: FilterData[] | undefined;
}

export class CreateInventoryOutboundCommand implements ICreateInventoryOutboundCommand {
    orderId?: number;

    constructor(data?: ICreateInventoryOutboundCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
        }
    }

    static fromJS(data: any): CreateInventoryOutboundCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInventoryOutboundCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        return data;
    }
}

export interface ICreateInventoryOutboundCommand {
    orderId?: number;
}

export class LogList implements ILogList {
    logVMs?: LogVM[];
    status?: number;
    page?: Page | undefined;

    constructor(data?: ILogList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["logVMs"])) {
                this.logVMs = [] as any;
                for (let item of _data["logVMs"])
                    this.logVMs!.push(LogVM.fromJS(item));
            }
            this.status = _data["status"];
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LogList {
        data = typeof data === 'object' ? data : {};
        let result = new LogList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.logVMs)) {
            data["logVMs"] = [];
            for (let item of this.logVMs)
                data["logVMs"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILogList {
    logVMs?: LogVM[];
    status?: number;
    page?: Page | undefined;
}

export class LogVM implements ILogVM {
    date?: string | undefined;
    logLevel?: string | undefined;
    message?: string | undefined;
    hour?: string | undefined;
    type?: string | undefined;

    constructor(data?: ILogVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.logLevel = _data["logLevel"];
            this.message = _data["message"];
            this.hour = _data["hour"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): LogVM {
        data = typeof data === 'object' ? data : {};
        let result = new LogVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["logLevel"] = this.logLevel;
        data["message"] = this.message;
        data["hour"] = this.hour;
        data["type"] = this.type;
        return data;
    }
}

export interface ILogVM {
    date?: string | undefined;
    logLevel?: string | undefined;
    message?: string | undefined;
    hour?: string | undefined;
    type?: string | undefined;
}

export class GetLogListQuery implements IGetLogListQuery {
    page?: Page | undefined;
    date?: Date | undefined;
    typeLog?: string | undefined;
    hour?: number | undefined;

    constructor(data?: IGetLogListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.typeLog = _data["typeLog"];
            this.hour = _data["hour"];
        }
    }

    static fromJS(data: any): GetLogListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetLogListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["typeLog"] = this.typeLog;
        data["hour"] = this.hour;
        return data;
    }
}

export interface IGetLogListQuery {
    page?: Page | undefined;
    date?: Date | undefined;
    typeLog?: string | undefined;
    hour?: number | undefined;
}

export class ImportStogareCommand implements IImportStogareCommand {
    totalPrice?: number;
    customerName?: string | undefined;
    customerPhoneNumber?: string | undefined;
    products?: ImportProductDto[] | undefined;

    constructor(data?: IImportStogareCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalPrice = _data["totalPrice"];
            this.customerName = _data["customerName"];
            this.customerPhoneNumber = _data["customerPhoneNumber"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ImportProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImportStogareCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ImportStogareCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalPrice"] = this.totalPrice;
        data["customerName"] = this.customerName;
        data["customerPhoneNumber"] = this.customerPhoneNumber;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface IImportStogareCommand {
    totalPrice?: number;
    customerName?: string | undefined;
    customerPhoneNumber?: string | undefined;
    products?: ImportProductDto[] | undefined;
}

export class ImportProductDto implements IImportProductDto {
    name?: string;
    unit?: string;
    quantity?: number;
    price?: number;
    note?: string | undefined;
    expiration?: Date;
    categoryId?: number;
    areaId?: number;
    storageId?: number;

    constructor(data?: IImportProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.unit = _data["unit"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.note = _data["note"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.areaId = _data["areaId"];
            this.storageId = _data["storageId"];
        }
    }

    static fromJS(data: any): ImportProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["note"] = this.note;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["areaId"] = this.areaId;
        data["storageId"] = this.storageId;
        return data;
    }
}

export interface IImportProductDto {
    name?: string;
    unit?: string;
    quantity?: number;
    price?: number;
    note?: string | undefined;
    expiration?: Date;
    categoryId?: number;
    areaId?: number;
    storageId?: number;
}

export class OrderListVM implements IOrderListVM {
    orders?: OrderDto[];
    page?: Page;

    constructor(data?: IOrderListVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["orders"])) {
                this.orders = [] as any;
                for (let item of _data["orders"])
                    this.orders!.push(OrderDto.fromJS(item));
            }
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderListVM {
        data = typeof data === 'object' ? data : {};
        let result = new OrderListVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOrderListVM {
    orders?: OrderDto[];
    page?: Page;
}

export class OrderDto implements IOrderDto {
    orderId?: string;
    type?: string;
    date?: Date;
    totalPrice?: number;
    orderDetailsCount?: number;
    totalQuantity?: number;

    constructor(data?: IOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.type = _data["type"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.totalPrice = _data["totalPrice"];
            this.orderDetailsCount = _data["orderDetailsCount"];
            this.totalQuantity = _data["totalQuantity"];
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["type"] = this.type;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["totalPrice"] = this.totalPrice;
        data["orderDetailsCount"] = this.orderDetailsCount;
        data["totalQuantity"] = this.totalQuantity;
        return data;
    }
}

export interface IOrderDto {
    orderId?: string;
    type?: string;
    date?: Date;
    totalPrice?: number;
    orderDetailsCount?: number;
    totalQuantity?: number;
}

export class GetOrderListQuery implements IGetOrderListQuery {
    page?: Page | undefined;

    constructor(data?: IGetOrderListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetOrderListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrderListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetOrderListQuery {
    page?: Page | undefined;
}

export class OrderDetailVM implements IOrderDetailVM {
    type?: string | undefined;
    date?: Date;
    totalPrice?: number;
    orderProductDtos?: OrderProductDto[] | undefined;

    constructor(data?: IOrderDetailVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.totalPrice = _data["totalPrice"];
            if (Array.isArray(_data["orderProductDtos"])) {
                this.orderProductDtos = [] as any;
                for (let item of _data["orderProductDtos"])
                    this.orderProductDtos!.push(OrderProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderDetailVM {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["totalPrice"] = this.totalPrice;
        if (Array.isArray(this.orderProductDtos)) {
            data["orderProductDtos"] = [];
            for (let item of this.orderProductDtos)
                data["orderProductDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrderDetailVM {
    type?: string | undefined;
    date?: Date;
    totalPrice?: number;
    orderProductDtos?: OrderProductDto[] | undefined;
}

export class OrderProductDto implements IOrderProductDto {
    productName?: string | undefined;
    quantity?: number;
    totalPrice?: number;
    units?: string | undefined;
    note?: string | undefined;

    constructor(data?: IOrderProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productName = _data["productName"];
            this.quantity = _data["quantity"];
            this.totalPrice = _data["totalPrice"];
            this.units = _data["units"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): OrderProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productName"] = this.productName;
        data["quantity"] = this.quantity;
        data["totalPrice"] = this.totalPrice;
        data["units"] = this.units;
        data["note"] = this.note;
        return data;
    }
}

export interface IOrderProductDto {
    productName?: string | undefined;
    quantity?: number;
    totalPrice?: number;
    units?: string | undefined;
    note?: string | undefined;
}

export class SaleOrderCommand implements ISaleOrderCommand {
    totalPrice?: number;
    customerId?: number;
    dateExport?: Date;
    products?: SaleOrderProduct[];

    constructor(data?: ISaleOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalPrice = _data["totalPrice"];
            this.customerId = _data["customerId"];
            this.dateExport = _data["dateExport"] ? new Date(_data["dateExport"].toString()) : <any>undefined;
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(SaleOrderProduct.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaleOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SaleOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalPrice"] = this.totalPrice;
        data["customerId"] = this.customerId;
        data["dateExport"] = this.dateExport ? this.dateExport.toISOString() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISaleOrderCommand {
    totalPrice?: number;
    customerId?: number;
    dateExport?: Date;
    products?: SaleOrderProduct[];
}

export class SaleOrderProduct implements ISaleOrderProduct {
    productName?: string;
    quantity?: number;
    price?: number;
    expectedPickupDate?: Date | undefined;

    constructor(data?: ISaleOrderProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productName = _data["productName"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.expectedPickupDate = _data["expectedPickupDate"] ? new Date(_data["expectedPickupDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SaleOrderProduct {
        data = typeof data === 'object' ? data : {};
        let result = new SaleOrderProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productName"] = this.productName;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["expectedPickupDate"] = this.expectedPickupDate ? this.expectedPickupDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISaleOrderProduct {
    productName?: string;
    quantity?: number;
    price?: number;
    expectedPickupDate?: Date | undefined;
}

export class SaleAndImportOrderVM implements ISaleAndImportOrderVM {
    saleOrders?: OrderDto2[] | undefined;
    importOrder?: OrderDto2[] | undefined;

    constructor(data?: ISaleAndImportOrderVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["saleOrders"])) {
                this.saleOrders = [] as any;
                for (let item of _data["saleOrders"])
                    this.saleOrders!.push(OrderDto2.fromJS(item));
            }
            if (Array.isArray(_data["importOrder"])) {
                this.importOrder = [] as any;
                for (let item of _data["importOrder"])
                    this.importOrder!.push(OrderDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaleAndImportOrderVM {
        data = typeof data === 'object' ? data : {};
        let result = new SaleAndImportOrderVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.saleOrders)) {
            data["saleOrders"] = [];
            for (let item of this.saleOrders)
                data["saleOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.importOrder)) {
            data["importOrder"] = [];
            for (let item of this.importOrder)
                data["importOrder"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISaleAndImportOrderVM {
    saleOrders?: OrderDto2[] | undefined;
    importOrder?: OrderDto2[] | undefined;
}

export class OrderDto2 implements IOrderDto2 {
    id?: string | undefined;
    type?: string | undefined;
    status?: string | undefined;
    date?: Date;
    totalPrice?: number;

    constructor(data?: IOrderDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.totalPrice = _data["totalPrice"];
        }
    }

    static fromJS(data: any): OrderDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["status"] = this.status;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["totalPrice"] = this.totalPrice;
        return data;
    }
}

export interface IOrderDto2 {
    id?: string | undefined;
    type?: string | undefined;
    status?: string | undefined;
    date?: Date;
    totalPrice?: number;
}

export class GetImportOrderListQuery implements IGetImportOrderListQuery {
    page?: Page;
    filters?: FilterData[] | undefined;

    constructor(data?: IGetImportOrderListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(FilterData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetImportOrderListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetImportOrderListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetImportOrderListQuery {
    page?: Page;
    filters?: FilterData[] | undefined;
}

export class GetSaleOrderListQuery implements IGetSaleOrderListQuery {
    page?: Page;
    filters?: FilterData[] | undefined;

    constructor(data?: IGetSaleOrderListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(FilterData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSaleOrderListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetSaleOrderListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetSaleOrderListQuery {
    page?: Page;
    filters?: FilterData[] | undefined;
}

export class ProductListVM implements IProductListVM {
    productList?: ProductDto[] | undefined;
    page?: Page | undefined;

    constructor(data?: IProductListVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["productList"])) {
                this.productList = [] as any;
                for (let item of _data["productList"])
                    this.productList!.push(ProductDto.fromJS(item));
            }
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductListVM {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.productList)) {
            data["productList"] = [];
            for (let item of this.productList)
                data["productList"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductListVM {
    productList?: ProductDto[] | undefined;
    page?: Page | undefined;
}

export class GetProductListQuery implements IGetProductListQuery {
    page?: Page;
    filters?: FilterData[] | undefined;

    constructor(data?: IGetProductListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(FilterData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProductListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetProductListQuery {
    page?: Page;
    filters?: FilterData[] | undefined;
}

export class ProductsOrderVM implements IProductsOrderVM {
    products?: ProductDto2[] | undefined;

    constructor(data?: IProductsOrderVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductsOrderVM {
        data = typeof data === 'object' ? data : {};
        let result = new ProductsOrderVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductsOrderVM {
    products?: ProductDto2[] | undefined;
}

export class ProductDto2 implements IProductDto2 {
    name?: string | undefined;

    constructor(data?: IProductDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProductDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IProductDto2 {
    name?: string | undefined;
}

export class ReportVM implements IReportVM {
    warehouseStatistics?: WarehousePerformance[];
    importStatistics?: ImportSummary[];
    topProducts?: ProductPerformance[];
    slowMovingProducts?: ProductPerformance[];
    totalRevenue?: number;
    totalImportCost?: number;
    totalOrders?: number;

    constructor(data?: IReportVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["warehouseStatistics"])) {
                this.warehouseStatistics = [] as any;
                for (let item of _data["warehouseStatistics"])
                    this.warehouseStatistics!.push(WarehousePerformance.fromJS(item));
            }
            if (Array.isArray(_data["importStatistics"])) {
                this.importStatistics = [] as any;
                for (let item of _data["importStatistics"])
                    this.importStatistics!.push(ImportSummary.fromJS(item));
            }
            if (Array.isArray(_data["topProducts"])) {
                this.topProducts = [] as any;
                for (let item of _data["topProducts"])
                    this.topProducts!.push(ProductPerformance.fromJS(item));
            }
            if (Array.isArray(_data["slowMovingProducts"])) {
                this.slowMovingProducts = [] as any;
                for (let item of _data["slowMovingProducts"])
                    this.slowMovingProducts!.push(ProductPerformance.fromJS(item));
            }
            this.totalRevenue = _data["totalRevenue"];
            this.totalImportCost = _data["totalImportCost"];
            this.totalOrders = _data["totalOrders"];
        }
    }

    static fromJS(data: any): ReportVM {
        data = typeof data === 'object' ? data : {};
        let result = new ReportVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.warehouseStatistics)) {
            data["warehouseStatistics"] = [];
            for (let item of this.warehouseStatistics)
                data["warehouseStatistics"].push(item.toJSON());
        }
        if (Array.isArray(this.importStatistics)) {
            data["importStatistics"] = [];
            for (let item of this.importStatistics)
                data["importStatistics"].push(item.toJSON());
        }
        if (Array.isArray(this.topProducts)) {
            data["topProducts"] = [];
            for (let item of this.topProducts)
                data["topProducts"].push(item.toJSON());
        }
        if (Array.isArray(this.slowMovingProducts)) {
            data["slowMovingProducts"] = [];
            for (let item of this.slowMovingProducts)
                data["slowMovingProducts"].push(item.toJSON());
        }
        data["totalRevenue"] = this.totalRevenue;
        data["totalImportCost"] = this.totalImportCost;
        data["totalOrders"] = this.totalOrders;
        return data;
    }
}

export interface IReportVM {
    warehouseStatistics?: WarehousePerformance[];
    importStatistics?: ImportSummary[];
    topProducts?: ProductPerformance[];
    slowMovingProducts?: ProductPerformance[];
    totalRevenue?: number;
    totalImportCost?: number;
    totalOrders?: number;
}

export class WarehousePerformance implements IWarehousePerformance {
    id?: number;
    warehouseName?: string | undefined;
    revenue?: number;

    constructor(data?: IWarehousePerformance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.warehouseName = _data["warehouseName"];
            this.revenue = _data["revenue"];
        }
    }

    static fromJS(data: any): WarehousePerformance {
        data = typeof data === 'object' ? data : {};
        let result = new WarehousePerformance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["warehouseName"] = this.warehouseName;
        data["revenue"] = this.revenue;
        return data;
    }
}

export interface IWarehousePerformance {
    id?: number;
    warehouseName?: string | undefined;
    revenue?: number;
}

export class ImportSummary implements IImportSummary {
    supplierName?: string | undefined;
    totalImportCost?: number;

    constructor(data?: IImportSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierName = _data["supplierName"];
            this.totalImportCost = _data["totalImportCost"];
        }
    }

    static fromJS(data: any): ImportSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ImportSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierName"] = this.supplierName;
        data["totalImportCost"] = this.totalImportCost;
        return data;
    }
}

export interface IImportSummary {
    supplierName?: string | undefined;
    totalImportCost?: number;
}

export class ProductPerformance implements IProductPerformance {
    storageId?: number;
    productName?: string | undefined;
    totalSold?: number;
    averageStorageTime?: number;

    constructor(data?: IProductPerformance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storageId = _data["storageId"];
            this.productName = _data["productName"];
            this.totalSold = _data["totalSold"];
            this.averageStorageTime = _data["averageStorageTime"];
        }
    }

    static fromJS(data: any): ProductPerformance {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPerformance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storageId"] = this.storageId;
        data["productName"] = this.productName;
        data["totalSold"] = this.totalSold;
        data["averageStorageTime"] = this.averageStorageTime;
        return data;
    }
}

export interface IProductPerformance {
    storageId?: number;
    productName?: string | undefined;
    totalSold?: number;
    averageStorageTime?: number;
}

export class AdminStatsVM implements IAdminStatsVM {
    totalInventoryValue?: number;
    onlineEmployeeCount?: number;
    orderCompletionRate?: number;
    highDemandItemName?: string;
    highDemandItemCount?: number;
    prediction?: Prediction | undefined;

    constructor(data?: IAdminStatsVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalInventoryValue = _data["totalInventoryValue"];
            this.onlineEmployeeCount = _data["onlineEmployeeCount"];
            this.orderCompletionRate = _data["orderCompletionRate"];
            this.highDemandItemName = _data["highDemandItemName"];
            this.highDemandItemCount = _data["highDemandItemCount"];
            this.prediction = _data["prediction"] ? Prediction.fromJS(_data["prediction"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdminStatsVM {
        data = typeof data === 'object' ? data : {};
        let result = new AdminStatsVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalInventoryValue"] = this.totalInventoryValue;
        data["onlineEmployeeCount"] = this.onlineEmployeeCount;
        data["orderCompletionRate"] = this.orderCompletionRate;
        data["highDemandItemName"] = this.highDemandItemName;
        data["highDemandItemCount"] = this.highDemandItemCount;
        data["prediction"] = this.prediction ? this.prediction.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAdminStatsVM {
    totalInventoryValue?: number;
    onlineEmployeeCount?: number;
    orderCompletionRate?: number;
    highDemandItemName?: string;
    highDemandItemCount?: number;
    prediction?: Prediction | undefined;
}

export class Prediction implements IPrediction {
    aI_predict?: number;
    accuracy?: number;
    date?: Date;

    constructor(data?: IPrediction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aI_predict = _data["aI_predict"];
            this.accuracy = _data["accuracy"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Prediction {
        data = typeof data === 'object' ? data : {};
        let result = new Prediction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aI_predict"] = this.aI_predict;
        data["accuracy"] = this.accuracy;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPrediction {
    aI_predict?: number;
    accuracy?: number;
    date?: Date;
}

export class EmployeeStatsVM implements IEmployeeStatsVM {
    outboundInventoryCompletePerMonth?: number;
    productExpirationCount?: number;
    totalProductImportPerMonth?: number;
    totalProductExportPerMonth?: number;

    constructor(data?: IEmployeeStatsVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outboundInventoryCompletePerMonth = _data["outboundInventoryCompletePerMonth"];
            this.productExpirationCount = _data["productExpirationCount"];
            this.totalProductImportPerMonth = _data["totalProductImportPerMonth"];
            this.totalProductExportPerMonth = _data["totalProductExportPerMonth"];
        }
    }

    static fromJS(data: any): EmployeeStatsVM {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeStatsVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outboundInventoryCompletePerMonth"] = this.outboundInventoryCompletePerMonth;
        data["productExpirationCount"] = this.productExpirationCount;
        data["totalProductImportPerMonth"] = this.totalProductImportPerMonth;
        data["totalProductExportPerMonth"] = this.totalProductExportPerMonth;
        return data;
    }
}

export interface IEmployeeStatsVM {
    outboundInventoryCompletePerMonth?: number;
    productExpirationCount?: number;
    totalProductImportPerMonth?: number;
    totalProductExportPerMonth?: number;
}

export class CreateStorageCommand implements ICreateStorageCommand {
    name?: string;
    location?: string;
    status?: StorageStatus;
    areas?: AreaDto[] | undefined;

    constructor(data?: ICreateStorageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.location = _data["location"];
            this.status = _data["status"];
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(AreaDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateStorageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStorageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["location"] = this.location;
        data["status"] = this.status;
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateStorageCommand {
    name?: string;
    location?: string;
    status?: StorageStatus;
    areas?: AreaDto[] | undefined;
}

export class StorageListVM implements IStorageListVM {
    storages?: StorageDto[] | undefined;

    constructor(data?: IStorageListVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["storages"])) {
                this.storages = [] as any;
                for (let item of _data["storages"])
                    this.storages!.push(StorageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StorageListVM {
        data = typeof data === 'object' ? data : {};
        let result = new StorageListVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.storages)) {
            data["storages"] = [];
            for (let item of this.storages)
                data["storages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStorageListVM {
    storages?: StorageDto[] | undefined;
}

export class UserStorageList implements IUserStorageList {
    storages?: StorageDto2[] | undefined;
    page?: Page | undefined;

    constructor(data?: IUserStorageList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["storages"])) {
                this.storages = [] as any;
                for (let item of _data["storages"])
                    this.storages!.push(StorageDto2.fromJS(item));
            }
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserStorageList {
        data = typeof data === 'object' ? data : {};
        let result = new UserStorageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.storages)) {
            data["storages"] = [];
            for (let item of this.storages)
                data["storages"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserStorageList {
    storages?: StorageDto2[] | undefined;
    page?: Page | undefined;
}

export class GetStorageOfUserQuery implements IGetStorageOfUserQuery {
    page?: Page | undefined;

    constructor(data?: IGetStorageOfUserQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetStorageOfUserQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetStorageOfUserQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetStorageOfUserQuery {
    page?: Page | undefined;
}

export class ListISorageInfoOfUserVM implements IListISorageInfoOfUserVM {
    storages?: StorageName[] | undefined;

    constructor(data?: IListISorageInfoOfUserVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["storages"])) {
                this.storages = [] as any;
                for (let item of _data["storages"])
                    this.storages!.push(StorageName.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListISorageInfoOfUserVM {
        data = typeof data === 'object' ? data : {};
        let result = new ListISorageInfoOfUserVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.storages)) {
            data["storages"] = [];
            for (let item of this.storages)
                data["storages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListISorageInfoOfUserVM {
    storages?: StorageName[] | undefined;
}

export class StorageName implements IStorageName {
    id?: number;
    name?: string | undefined;

    constructor(data?: IStorageName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): StorageName {
        data = typeof data === 'object' ? data : {};
        let result = new StorageName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IStorageName {
    id?: number;
    name?: string | undefined;
}

export class StorageProductListVM implements IStorageProductListVM {
    products?: ProductDto3[];
    page?: Page;

    constructor(data?: IStorageProductListVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductDto3.fromJS(item));
            }
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StorageProductListVM {
        data = typeof data === 'object' ? data : {};
        let result = new StorageProductListVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStorageProductListVM {
    products?: ProductDto3[];
    page?: Page;
}

export class ProductDto3 implements IProductDto3 {
    name?: string;
    units?: string;
    amount?: number;
    image?: string | undefined;
    status?: string;
    expiration?: Date;
    importDate?: Date;
    exportDate?: Date;
    safeStock?: number;
    totalPrice?: number;

    constructor(data?: IProductDto3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.units = _data["units"];
            this.amount = _data["amount"];
            this.image = _data["image"];
            this.status = _data["status"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.importDate = _data["importDate"] ? new Date(_data["importDate"].toString()) : <any>undefined;
            this.exportDate = _data["exportDate"] ? new Date(_data["exportDate"].toString()) : <any>undefined;
            this.safeStock = _data["safeStock"];
            this.totalPrice = _data["totalPrice"];
        }
    }

    static fromJS(data: any): ProductDto3 {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["units"] = this.units;
        data["amount"] = this.amount;
        data["image"] = this.image;
        data["status"] = this.status;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["importDate"] = this.importDate ? this.importDate.toISOString() : <any>undefined;
        data["exportDate"] = this.exportDate ? this.exportDate.toISOString() : <any>undefined;
        data["safeStock"] = this.safeStock;
        data["totalPrice"] = this.totalPrice;
        return data;
    }
}

export interface IProductDto3 {
    name?: string;
    units?: string;
    amount?: number;
    image?: string | undefined;
    status?: string;
    expiration?: Date;
    importDate?: Date;
    exportDate?: Date;
    safeStock?: number;
    totalPrice?: number;
}

export class GetStorageProductsQuery implements IGetStorageProductsQuery {
    storageId?: number;
    page?: Page | undefined;
    searchText?: string | undefined;
    filterData?: FilterData[] | undefined;

    constructor(data?: IGetStorageProductsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storageId = _data["storageId"];
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
            this.searchText = _data["searchText"];
            if (Array.isArray(_data["filterData"])) {
                this.filterData = [] as any;
                for (let item of _data["filterData"])
                    this.filterData!.push(FilterData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetStorageProductsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetStorageProductsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storageId"] = this.storageId;
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        data["searchText"] = this.searchText;
        if (Array.isArray(this.filterData)) {
            data["filterData"] = [];
            for (let item of this.filterData)
                data["filterData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetStorageProductsQuery {
    storageId?: number;
    page?: Page | undefined;
    searchText?: string | undefined;
    filterData?: FilterData[] | undefined;
}

export class StorageDto3 implements IStorageDto3 {
    id?: number;
    name?: string | undefined;
    location?: string | undefined;
    status?: string | undefined;
    areas?: AreaDto2[] | undefined;

    constructor(data?: IStorageDto3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.location = _data["location"];
            this.status = _data["status"];
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(AreaDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StorageDto3 {
        data = typeof data === 'object' ? data : {};
        let result = new StorageDto3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["location"] = this.location;
        data["status"] = this.status;
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStorageDto3 {
    id?: number;
    name?: string | undefined;
    location?: string | undefined;
    status?: string | undefined;
    areas?: AreaDto2[] | undefined;
}

export class UpdateStorageCommand implements IUpdateStorageCommand {
    storageId?: number;
    name?: string | undefined;
    location?: string | undefined;
    status?: string | undefined;
    areas?: AreaDto2[] | undefined;

    constructor(data?: IUpdateStorageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storageId = _data["storageId"];
            this.name = _data["name"];
            this.location = _data["location"];
            this.status = _data["status"];
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(AreaDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateStorageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStorageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storageId"] = this.storageId;
        data["name"] = this.name;
        data["location"] = this.location;
        data["status"] = this.status;
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateStorageCommand {
    storageId?: number;
    name?: string | undefined;
    location?: string | undefined;
    status?: string | undefined;
    areas?: AreaDto2[] | undefined;
}

export class CreateUserCommand implements ICreateUserCommand {
    userRegister?: UserRegister;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRegister = _data["userRegister"] ? UserRegister.fromJS(_data["userRegister"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRegister"] = this.userRegister ? this.userRegister.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateUserCommand {
    userRegister?: UserRegister;
}

export class UserRegister implements IUserRegister {
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    companyId?: string | undefined;
    roleName?: string | undefined;

    constructor(data?: IUserRegister) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.companyId = _data["companyId"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserRegister {
        data = typeof data === 'object' ? data : {};
        let result = new UserRegister();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["companyId"] = this.companyId;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IUserRegister {
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    companyId?: string | undefined;
    roleName?: string | undefined;
}

export class UserListVm implements IUserListVm {
    users?: UserDto[];
    page?: Page | undefined;

    constructor(data?: IUserListVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserDto.fromJS(item));
            }
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserListVm {
        data = typeof data === 'object' ? data : {};
        let result = new UserListVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserListVm {
    users?: UserDto[];
    page?: Page | undefined;
}

export class GetUserListQuery implements IGetUserListQuery {
    page?: Page | undefined;
    searchText?: string | undefined;

    constructor(data?: IGetUserListQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"] ? Page.fromJS(_data["page"]) : <any>undefined;
            this.searchText = _data["searchText"];
        }
    }

    static fromJS(data: any): GetUserListQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserListQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        data["searchText"] = this.searchText;
        return data;
    }
}

export interface IGetUserListQuery {
    page?: Page | undefined;
    searchText?: string | undefined;
}

export class UserVM implements IUserVM {
    id?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    companyName?: string | undefined;
    companyId?: string | undefined;
    companyPhone?: string | undefined;
    companyEmail?: string | undefined;
    companyAddress?: string | undefined;
    storages?: StorageDto[] | undefined;
    avatarImage?: string | undefined;

    constructor(data?: IUserVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.companyName = _data["companyName"];
            this.companyId = _data["companyId"];
            this.companyPhone = _data["companyPhone"];
            this.companyEmail = _data["companyEmail"];
            this.companyAddress = _data["companyAddress"];
            if (Array.isArray(_data["storages"])) {
                this.storages = [] as any;
                for (let item of _data["storages"])
                    this.storages!.push(StorageDto.fromJS(item));
            }
            this.avatarImage = _data["avatarImage"];
        }
    }

    static fromJS(data: any): UserVM {
        data = typeof data === 'object' ? data : {};
        let result = new UserVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["companyName"] = this.companyName;
        data["companyId"] = this.companyId;
        data["companyPhone"] = this.companyPhone;
        data["companyEmail"] = this.companyEmail;
        data["companyAddress"] = this.companyAddress;
        if (Array.isArray(this.storages)) {
            data["storages"] = [];
            for (let item of this.storages)
                data["storages"].push(item.toJSON());
        }
        data["avatarImage"] = this.avatarImage;
        return data;
    }
}

export interface IUserVM {
    id?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    companyName?: string | undefined;
    companyId?: string | undefined;
    companyPhone?: string | undefined;
    companyEmail?: string | undefined;
    companyAddress?: string | undefined;
    storages?: StorageDto[] | undefined;
    avatarImage?: string | undefined;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    id?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    roleName?: string | undefined;
    companyId?: string | undefined;
    isActived?: boolean;
    avatarImage?: string | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.roleName = _data["roleName"];
            this.companyId = _data["companyId"];
            this.isActived = _data["isActived"];
            this.avatarImage = _data["avatarImage"];
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["roleName"] = this.roleName;
        data["companyId"] = this.companyId;
        data["isActived"] = this.isActived;
        data["avatarImage"] = this.avatarImage;
        return data;
    }
}

export interface IUpdateUserCommand {
    id?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    roleName?: string | undefined;
    companyId?: string | undefined;
    isActived?: boolean;
    avatarImage?: string | undefined;
}

export class SuperAdminStatsVM implements ISuperAdminStatsVM {
    totalUser?: number;
    totalCompany?: number;
    cpu?: number;
    ram?: number;
    prediction?: Prediction | undefined;

    constructor(data?: ISuperAdminStatsVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalUser = _data["totalUser"];
            this.totalCompany = _data["totalCompany"];
            this.cpu = _data["cpu"];
            this.ram = _data["ram"];
            this.prediction = _data["prediction"] ? Prediction.fromJS(_data["prediction"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SuperAdminStatsVM {
        data = typeof data === 'object' ? data : {};
        let result = new SuperAdminStatsVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalUser"] = this.totalUser;
        data["totalCompany"] = this.totalCompany;
        data["cpu"] = this.cpu;
        data["ram"] = this.ram;
        data["prediction"] = this.prediction ? this.prediction.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISuperAdminStatsVM {
    totalUser?: number;
    totalCompany?: number;
    cpu?: number;
    ram?: number;
    prediction?: Prediction | undefined;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}